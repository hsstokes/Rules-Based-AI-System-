<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tactile Thresholds</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
        }
        
        #p5-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: pointer;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #startOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        #startTitle {
            font-size: 24px;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            letter-spacing: 1px;
        }
        
        #startDescription {
            max-width: 500px;
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 40px;
            text-align: center;
            color: #555;
            padding: 0 20px;
        }
        
        #startButton {
            padding: 12px 30px;
            font-size: 18px;
            background-color: transparent;
            color: #0066cc;
            border: 1px solid #0066cc;
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 1px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
        }
        
        #startButton:hover {
            background-color: rgba(0, 102, 204, 0.1);
        }
        
        #startButton:active {
            transform: scale(0.98);
        }
        
        #soundButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background-color: transparent;
            border: none;
            border-radius: 0;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        #soundButton img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        #soundButton:active {
            transform: translateX(-50%) scale(0.95);
        }
        
        /* Feedback overlay */
        #feedbackOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
        }
        
        #feedbackTitle {
            font-size: 22px;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }
        
        #feedbackForm {
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .emotion-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .emotion-option {
            margin: 5px;
            padding: 12px 16px;
            background-color: transparent;
            border: 1px solid #0066cc;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: rgba(0, 102, 204, 0.3);
            touch-action: manipulation;
        }
        
        .emotion-option.selected {
            background-color: #0066cc;
            color: white;
        }
        
        .slider-container {
            width: 100%;
            margin-bottom: 25px;
        }
        
        .slider-label {
            display: block;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .alignment-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 25px;
            border-radius: 4px;
            background: #d3d3d3;
            outline: none;
            margin-bottom: 15px;
        }
        
        .alignment-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #0066cc;
            cursor: pointer;
        }
        
        .slider-values {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 12px;
            color: #666;
        }
        
        #submitFeedback {
            padding: 12px 30px;
            font-size: 16px;
            background-color: #0066cc;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            min-width: 180px;
            margin-top: 10px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        #submitFeedback:hover {
            background-color: #0055aa;
        }
        
        #submitFeedback:active {
            transform: scale(0.98);
        }
        
        /* Visualization panel */
        #vizPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            z-index: 800;
            display: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #vizToggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background-color: rgba(0, 102, 204, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 801;
            font-family: 'Roboto Mono', monospace;
            display: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        /* Framework visualization elements */
        .dimension-container {
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
        }
        
        .dimension-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .dimension-scale {
            height: 15px;
            width: 100%;
            background: linear-gradient(to right, #3498db, #e74c3c);
            border-radius: 3px;
            position: relative;
            margin: 8px 0;
        }
        
        .dimension-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
        }
        
        .dimension-marker {
            position: absolute;
            width: 8px;
            height: 20px;
            background-color: #333;
            border-radius: 2px;
            top: -2px;
            transform: translateX(-50%);
        }
        
        /* Node selector for different soundscapes */
        #nodeSelector {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-wrap: wrap;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 500;
            display: none;
        }
        
        .node-button {
            margin: 5px;
            padding: 8px 12px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.2s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        .node-button.active {
            outline: 2px solid #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="p5-container"></div>
    <div id="startOverlay">
        <div id="startTitle">Tactile Thresholds</div>
        <div id="startDescription">
            "Rules-Based AI System": Explore the intersection of physical and digital through touch. 
            Each interaction generates unique sound compositions that map the 
            emotional relationships between human and AI.
        </div>
        <button id="startButton">BEGIN INTERACTION</button>
    </div>
    <div id="soundButton">
        <img src="images/your-button-image.png" alt="Sound Button">
    </div>
    
    <!-- Feedback overlay -->
    <div id="feedbackOverlay">
        <div id="feedbackTitle">How did this sound make you feel?</div>
        <form id="feedbackForm">
            <div class="emotion-options">
                <button type="button" class="emotion-option" data-emotion="analytical">Analytical</button>
                <button type="button" class="emotion-option" data-emotion="embodied">Embodied</button>
                <button type="button" class="emotion-option" data-emotion="temporal">Temporal</button>
                <button type="button" class="emotion-option" data-emotion="atemporal">Atemporal</button>
                <button type="button" class="emotion-option" data-emotion="contextual">Contextual</button>
                <button type="button" class="emotion-option" data-emotion="decontextualized">Decontextualized</button>
                <button type="button" class="emotion-option" data-emotion="intuitive">Intuitive</button>
                <button type="button" class="emotion-option" data-emotion="computational">Computational</button>
            </div>
            
            <div class="slider-container">
                <label class="slider-label">How well did the sound match the emotion you selected?</label>
                <input type="range" min="1" max="10" value="5" class="alignment-slider" id="alignmentSlider">
                <div class="slider-values">
                    <span>Misaligned</span>
                    <span>Perfect Match</span>
                </div>
            </div>
            
            <div class="slider-container">
                <label class="slider-label">Did this interaction feel "uncanny"?</label>
                <input type="range" min="1" max="10" value="5" class="alignment-slider" id="uncannySlider">
                <div class="slider-values">
                    <span>Natural</span>
                    <span>Deeply Uncanny</span>
                </div>
            </div>
            
            <button type="button" id="submitFeedback">Continue</button>
        </form>
    </div>
    
    <!-- Visualization panel -->
    <button id="vizToggle">View Empathy Framework</button>
    <div id="vizPanel">
        <h3 style="margin-top: 0; font-size: 16px;">Dimensional Empathy Framework</h3>
        
        <!-- Analytical vs Embodied -->
        <div class="dimension-container">
            <div class="dimension-title">Analytical ↔ Embodied</div>
            <div class="dimension-scale">
                <div class="dimension-marker" id="marker-analytical" style="left: 25%;"></div>
            </div>
            <div class="dimension-labels">
                <span>Analytical</span>
                <span>Embodied</span>
            </div>
        </div>
        
        <!-- Temporal vs Atemporal -->
        <div class="dimension-container">
            <div class="dimension-title">Temporal ↔ Atemporal</div>
            <div class="dimension-scale">
                <div class="dimension-marker" id="marker-temporal" style="left: 25%;"></div>
            </div>
            <div class="dimension-labels">
                <span>Temporal</span>
                <span>Atemporal</span>
            </div>
        </div>
        
        <!-- Contextual vs Decontextualized -->
        <div class="dimension-container">
            <div class="dimension-title">Contextual ↔ Decontextualized</div>
            <div class="dimension-scale">
                <div class="dimension-marker" id="marker-contextual" style="left: 25%;"></div>
            </div>
            <div class="dimension-labels">
                <span>Contextual</span>
                <span>Decontextualized</span>
            </div>
        </div>
        
        <!-- Intuitive vs Computational -->
        <div class="dimension-container">
            <div class="dimension-title">Intuitive ↔ Computational</div>
            <div class="dimension-scale">
                <div class="dimension-marker" id="marker-intuitive" style="left: 25%;"></div>
            </div>
            <div class="dimension-labels">
                <span>Intuitive</span>
                <span>Computational</span>
            </div>
        </div>
        
        <div id="resultsContainer">
            <h4 style="font-size: 14px; margin-bottom: 10px;">Response Summary</h4>
            <div id="responseCount">Interactions: 0</div>
            <div id="uncannyScore">Average Uncanny Score: -</div>
            <div id="alignmentScore">Average Alignment: -</div>
        </div>
    </div>
    
    <!-- Node selector for different soundscapes -->
    <div id="nodeSelector"></div>
    
    <script>
        // Game variables
        let walkRight = [];
        let walkLeft = [];
        let gridImg;
        let bulletSound;
        let bullets = [];
        let shoot = 0;
        let gameStarted = false;
        let soundsLoaded = false;
        let soundInitialized = false;
        let soldier;
        
        // Canvas dimensions
        let W_WIDTH = 1920;
        let W_HEIGHT = 1920;
        
        // Feedback variables
        let feedbackData = [];
        let currentMode = "rules-based"; // Start with rules-based mode
        let showingFeedback = false;
        let interactionCount = 0;
        
        // Framework dimensions with initial values (AI perspective)
        let framework = {
            analytical: 0.75, // 0 = analytical, 1 = embodied
            temporal: 0.25,   // 0 = temporal, 1 = atemporal
            contextual: 0.25, // 0 = contextual, 1 = decontextualized
            intuitive: 0.15   // 0 = intuitive, 1 = computational
        };
        
        // Human perception (will be updated based on feedback)
        let humanPerception = {
            analytical: 0.5,
            temporal: 0.5,
            contextual: 0.5,
            intuitive: 0.5
        };
        
        // Define the framework nodes with their initial properties
        const frameworkNodes = {
            "rules-based-ai": {
                colors: {r: [0, 50], g: [0, 100], b: [200, 255]}, // Blue
                altColors: {r: [200, 255], g: [0, 50], b: [0, 50]}, // Red
                effectType: 0, // Single rectangle
                movementType: "random",
                soundFile: "sounds/Bulletsound.mp3"
            },
            "high-fidelity": {
                colors: {r: [0, 50], g: [50, 100], b: [150, 200]}, // Dark blue
                effectType: 1, // Grid pattern
                movementType: "smooth",
                soundFile: "sounds/high-fidelity.mp3"
            },
            "sharp-rectangle": {
                colors: {r: [180, 220], g: [180, 220], b: [180, 220]}, // Light grays
                effectType: 1, // Grid pattern
                movementType: "angular",
                soundFile: "sounds/sharp-rectangle.mp3"
            },
            "rigid-path": {
                colors: {r: [200, 255], g: [200, 255], b: [0, 100]}, // Yellow
                effectType: 0, // Single rectangle
                movementType: "straight",
                soundFile: "sounds/rigid-path.mp3"
            },
            "repetitive-listing": {
                colors: {r: [180, 220], g: [50, 100], b: [180, 220]}, // Purple
                effectType: 2, // Layered
                movementType: "pulsing",
                soundFile: "sounds/repetitive-listing.mp3"
            },
            "embodied": {
                colors: {r: [100, 150], g: [200, 255], b: [100, 150]}, // Green
                effectType: 2, // Layered
                movementType: "organic",
                soundFile: "sounds/embodied.mp3"
            },
            "temporal": {
                colors: {r: [100, 150], g: [100, 150], b: [200, 255]}, // Light blue
                effectType: 0, // Single
                movementType: "sequential",
                soundFile: "sounds/temporal.mp3"
            },
            "intuitive": {
                colors: {r: [255, 200], g: [150, 200], b: [50, 100]}, // Orange
                effectType: 2, // Layered
                movementType: "flowing",
                soundFile: "sounds/intuitive.mp3"
            },
            "contextual": {
                colors: {r: [150, 200], g: [150, 200], b: [150, 200]}, // Medium gray
                effectType: 1, // Grid
                movementType: "reactive",
                soundFile: "sounds/contextual.mp3"
            }
        };
        
        // Current node/soundscape
        let currentNode = "rules-based-ai";
        
        // Player class
        class Player {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.vel = 4;
                this.walkCount = 0;
                this.standing = true;
                this.last_direction = "right";
                this.hitbox = {
                    x: this.x + 75,
                    y: this.y + 75,
                    width: this.width - 150,
                    height: this.height - 150
                };
            }
            
            draw() {
                let frames;
                if (this.last_direction === "right") {
                    frames = walkRight;
                } else {
                    frames = walkLeft;
                }
                
                if (this.walkCount >= frames.length) {
                    this.walkCount = 0;
                }
                
                // Use raw canvas API for blend mode but with higher opacity
                let ctx = drawingContext;
                ctx.save();
                ctx.globalCompositeOperation = 'darken';
                ctx.globalAlpha = 1.0; // Less transparent (0.9 -> 1.0)
                
                // Draw the frame at exact dimensions
                if (frames[this.walkCount] && frames[this.walkCount].canvas) {
                    ctx.drawImage(frames[this.walkCount].canvas, this.x, this.y, this.width, this.height);
                }
                
                // Restore canvas state
                ctx.restore();
                
                this.walkCount += 1;
                if (this.walkCount >= frames.length) {
                    this.walkCount = 0;
                }
                
                // Update hitbox with current position
                this.hitbox = {
                    x: this.x + 75,
                    y: this.y + 75,
                    width: this.width - 150,
                    height: this.height - 150
                };
            }
        }
        
        // Rectangle grid effect (modified from circles)
        class Projectile {
            constructor(x, y, radius, colour, direction, effectType, movementType) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.colour = colour;
                this.direction = direction;
                this.effectType = effectType || floor(random(3));
                this.movementType = movementType || "random";
                
                // Set up movement based on type
                if (this.movementType === "random") {
                    // Random velocity components
                    const angle = random(0, TWO_PI);
                    const speed = random(2, 8);
                    this.velX = speed * cos(angle);
                    this.velY = speed * sin(angle);
                } else if (this.movementType === "straight") {
                    // Straight paths
                    this.velX = random() < 0.5 ? 5 : -5;
                    this.velY = random() < 0.5 ? 5 : -5;
                } else if (this.movementType === "angular") {
                    // Angular movement
                    const angle = random([0, PI/2, PI, 3*PI/2]); // Only 0, 90, 180, 270 degrees
                    const speed = random(3, 6);
                    this.velX = speed * cos(angle);
                    this.velY = speed * sin(angle);
                } else if (this.movementType === "flowing") {
                    // Flowing, organic movement
                    const angle = random(0, TWO_PI);
                    const speed = random(1, 4);
                    this.velX = speed * cos(angle);
                    this.velY = speed * sin(angle);
                    this.flowOffset = random(1000);
                } else if (this.movementType === "pulsing") {
                    // Pulsing movement
                    const angle = random(0, TWO_PI);
                    const speed = random(2, 5);
                    this.velX = speed * cos(angle);
                    this.velY = speed * sin(angle);
                    this.pulseRate = random(0.05, 0.2);
                } else if (this.movementType === "sequential") {
                    // Sequential movement
                    this.moveStep = 0;
                    this.moveSequence = [
                        {x: 4, y: 0}, {x: 0, y: 4}, {x: -4, y: 0}, {x: 0, y: -4}
                    ];
                    this.moveTimer = 0;
                    this.moveInterval = floor(random(10, 20));
                    this.velX = this.moveSequence[0].x;
                    this.velY = this.moveSequence[0].y;
                } else {
                    // Default movement
                    const angle = random(0, TWO_PI);
                    const speed = random(2, 8);
                    this.velX = speed * cos(angle);
                    this.velY = speed * sin(angle);
                }
                
                // Random lifetime
                this.lifetime = random(30, 120);
                this.age = 0;
                this.growing = true;
                this.maxRadius = radius * random(3, 8);
                
                // Rotation properties
                this.rotation = random(TWO_PI);
                
                // Rotation speed based on movement type
                if (this.movementType === "angular" || this.movementType === "straight") {
                    this.rotationSpeed = 0; // No rotation for angular/straight
                } else if (this.movementType === "flowing") {
                    this.rotationSpeed = random(-0.1, 0.1); // More rotation for flowing
                } else {
                    this.rotationSpeed = random(-0.05, 0.05); // Normal rotation
                }
            }
            
            draw() {
                // Handle special movement types
                if (this.movementType === "flowing") {
                    // Add some perlin noise to movement
                    this.velX += map(noise(this.flowOffset, frameCount * 0.01), 0, 1, -0.2, 0.2);
                    this.velY += map(noise(this.flowOffset + 1000, frameCount * 0.01), 0, 1, -0.2, 0.2);
                } else if (this.movementType === "pulsing") {
                    // Pulsing size
                    this.radius += sin(frameCount * this.pulseRate) * 0.5;
                } else if (this.movementType === "sequential") {
                    // Sequential movement
                    this.moveTimer++;
                    if (this.moveTimer >= this.moveInterval) {
                        this.moveTimer = 0;
                        this.moveStep = (this.moveStep + 1) % this.moveSequence.length;
                        this.velX = this.moveSequence[this.moveStep].x;
                        this.velY = this.moveSequence[this.moveStep].y;
                    }
                }
                
                // Standard drawing code
                push();
                translate(this.x, this.y);
                rotate(this.rotation);
                
                // Set color with alpha
                noStroke();
                const alpha = map(this.age, 0, this.lifetime, 255, 0);
                fill(red(this.colour), green(this.colour), blue(this.colour), alpha);
                
                // Draw rectangles based on effect type
                this.drawRectEffect(0, 0, this.radius);
                
                pop();
                
                // Update position
                this.x += this.velX;
                this.y += this.velY;
                
                // Update rotation
                this.rotation += this.rotationSpeed;
                
                // Update size - faster growth
                if (this.growing) {
                    this.radius += 0.4;
                    if (this.radius >= this.maxRadius) {
                        this.growing = false;
                    }
                } else {
                    this.radius = max(0, this.radius - 0.05);
                }
                
                // Update age
                this.age++;
            }
            
            // Method to draw rectangle effects
            drawRectEffect(x, y, radius) {
                rectMode(CENTER);
                
                if (this.effectType === 0) {
                    // Single sharp rectangle
                    rect(x, y, radius * 2, radius * 2);
                } else if (this.effectType === 1) {
                    // Grid pattern
                    const gridSize = 3;
                    const cellSize = radius * 2 / gridSize;
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            if (random() > 0.3) { // Random gaps
                                rect(
                                    (i - gridSize/2 + 0.5) * cellSize,
                                    (j - gridSize/2 + 0.5) * cellSize,
                                    cellSize * 0.8,
                                    cellSize * 0.8
                                );
                            }
                        }
                    }
                } else {
                    // Layered rectangles
                    for (let i = 0; i < 3; i++) {
                        const currentAlpha = map(this.age, 0, this.lifetime, 255, 0) / (i + 1);
                        fill(red(this.colour), green(this.colour), blue(this.colour), currentAlpha);
                        rect(x, y, radius * 2 * (1 - i * 0.2), radius * 2 * (1 - i * 0.2));
                    }
                }
            }
            
            isFinished() {
                return this.age >= this.lifetime;
            }
        }
        
        // Preload assets
        function preload() {
            // Load background
            gridImg = loadImage('images/grid_img.jpeg');
            
            // Load character images
            for (let i = 1; i <= 6; i++) {
                walkRight.push(loadImage(`soldier/${i}.png`));
                walkLeft.push(loadImage(`soldier/L${i}.png`));
            }
            
            // Sound loading
            soundFormats('mp3');
            bulletSound = loadSound('sounds/Bulletsound.mp3');
            
            // Additional sounds would be loaded here
            // For prototype, we'll use the same sound for all nodes
        }
        
        function setup() {
            // Create canvas matching game dimensions and place it in the container
            let canvas;
            
            // Calculate the canvas dimensions while maintaining aspect ratio
            let canvasWidth, canvasHeight;
            
            if (windowWidth / windowHeight > W_WIDTH / W_HEIGHT) {
                // Window is wider than the target aspect ratio
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * (W_WIDTH / W_HEIGHT);
            } else {
                // Window is taller than the target aspect ratio
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth * (W_HEIGHT / W_WIDTH);
            }
            
            canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('p5-container');
            
            // Improve mobile interaction for canvas
            canvas.mousePressed(handleCanvasClick);
            canvas.touchStarted(function() {
                handleCanvasClick();
                return false;
            });
            canvas.touchEnded(function() {
                // Only handle if not in the middle of a transition
                if (gameStarted && !showingFeedback) {
                    handleCanvasClick();
                }
                return false;
            });
            
            // Create character  
            soldier = new Player(width/2 - 245, height/2 - 245, 490, 490);
            
            // Set up start button with improved mobile handling
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('startButton').addEventListener('touchend', function(e) {
                e.preventDefault();
                startGame();
            });
            
            // Sound button for mobiles
            document.getElementById('soundButton').addEventListener('click', handleCanvasClick);
            document.getElementById('soundButton').addEventListener('touchend', function(e) {
                e.preventDefault();
                handleCanvasClick();
            });
            
            // Add interaction to container div as well
            document.getElementById('p5-container').addEventListener('click', handleCanvasClick);
            document.getElementById('p5-container').addEventListener('touchend', function(e) {
                // Only trigger if game has started and not from control buttons
                if (gameStarted && e.target.id !== 'soundButton' && !showingFeedback) {
                    handleCanvasClick();
                    e.preventDefault();
                }
            });
            
            // Set up feedback form
            setupFeedbackForm();
            
            // Set up visualization toggle
            document.getElementById('vizToggle').addEventListener('click', toggleVizPanel);
            document.getElementById('vizToggle').addEventListener('touchend', function(e) {
                e.preventDefault();
                toggleVizPanel();
            });
            
            // Set up node selector
            setupNodeSelector();
            
            // Update framework visualization
            updateFrameworkVisualization();
            
            frameRate(12); // Smoother framerate
            
            // Create AudioContext
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            window.audioContext = new AudioContext();
            
            // Prevent default touch behavior across the app
            document.addEventListener('touchmove', function(e) {
                // Prevent scrolling when in the game
                if (gameStarted) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        function setupFeedbackForm() {
            // Set up emotion option buttons with improved mobile handling
            const emotionButtons = document.querySelectorAll('.emotion-option');
            
            emotionButtons.forEach(button => {
                // Use both click and touchend events for better mobile response
                const selectEmotion = function(e) {
                    e.preventDefault(); // Prevent default behavior
                    
                    // Remove selected class from all buttons
                    emotionButtons.forEach(btn => btn.classList.remove('selected'));
                    
                    // Add selected class to clicked button
                    this.classList.add('selected');
                    
                    // Add vibration feedback if available
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                };
                
                // Add both event listeners
                button.addEventListener('click', selectEmotion);
                button.addEventListener('touchend', selectEmotion);
            });
            
            // Set up submit button with improved mobile handling
            const submitButton = document.getElementById('submitFeedback');
            
            const handleSubmit = function(e) {
                e.preventDefault(); // Prevent default behavior
                
                // Add vibration feedback if available
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
                
                submitFeedback();
            };
            
            // Add both event listeners to submit button
            submitButton.addEventListener('click', handleSubmit);
            submitButton.addEventListener('touchend', handleSubmit);
            
            // Add an additional close method for mobile (tap outside the form)
            const overlay = document.getElementById('feedbackOverlay');
            const form = document.getElementById('feedbackForm');
            
            const closeOnTapOutside = function(e) {
                // If user taps outside the form but on the overlay, close it
                if (e.target === overlay) {
                    hideFeedbackForm();
                }
            };
            
            overlay.addEventListener('click', closeOnTapOutside);
            overlay.addEventListener('touchend', closeOnTapOutside);
        }
        
        function setupNodeSelector() {
            const selector = document.getElementById('nodeSelector');
            
            // Create a button for each node
            Object.keys(frameworkNodes).forEach(nodeName => {
                const btn = document.createElement('button');
                btn.className = 'node-button';
                btn.dataset.node = nodeName;
                btn.textContent = nodeName.replace(/-/g, ' ');
                
                // Set button color based on node colors
                const node = frameworkNodes[nodeName];
                const r = Math.floor((node.colors.r[0] + node.colors.r[1]) / 2);
                const g = Math.floor((node.colors.g[0] + node.colors.g[1]) / 2);
                const b = Math.floor((node.colors.b[0] + node.colors.b[1]) / 2);
                btn.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                
                // Set text color to be visible against the background
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                btn.style.color = brightness > 128 ? 'black' : 'white';
                
                // Mark the current node as active
                if (nodeName === currentNode) {
                    btn.classList.add('active');
                }
                
                // Add click handler with mobile support
                const handleNodeSelect = function(e) {
                    e.preventDefault();
                    changeNode(nodeName);
                    
                    // Remove active class from all buttons
                    document.querySelectorAll('.node-button').forEach(b => b.classList.remove('active'));
                    
                    // Add active class to this button
                    this.classList.add('active');
                    
                    // Vibration feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                };
                
                btn.addEventListener('click', handleNodeSelect);
                btn.addEventListener('touchend', handleNodeSelect);
                
                selector.appendChild(btn);
            });
        }
        
        function showFeedbackForm() {
            showingFeedback = true;
            document.getElementById('feedbackOverlay').style.display = 'flex';
            document.getElementById('soundButton').style.display = 'none';
            document.getElementById('nodeSelector').style.display = 'none';
            
            // For mobile: ensure the overlay is properly positioned and scroll to top
            window.scrollTo(0, 0);
            
            // Disable background scrolling when feedback is shown
            document.body.style.overflow = 'hidden';
        }
        
        function hideFeedbackForm() {
            showingFeedback = false;
            document.getElementById('feedbackOverlay').style.display = 'none';
            document.getElementById('soundButton').style.display = 'flex';
            document.getElementById('nodeSelector').style.display = 'flex';
            
            // Re-enable scrolling
            document.body.style.overflow = '';
            
            // Reset form
            document.querySelectorAll('.emotion-option').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('alignmentSlider').value = 5;
            document.getElementById('uncannySlider').value = 5;
        }
        
        function submitFeedback() {
            // Get selected emotion
            const selectedButton = document.querySelector('.emotion-option.selected');
            let selectedEmotion = selectedButton ? selectedButton.dataset.emotion : "none";
            
            // Get slider values
            const alignmentValue = parseInt(document.getElementById('alignmentSlider').value);
            const uncannyValue = parseInt(document.getElementById('uncannySlider').value);
            
            // Store feedback
            feedbackData.push({
                mode: currentMode,
                node: currentNode,
                perceivedEmotion: selectedEmotion,
                alignmentScore: alignmentValue,
                uncannyScore: uncannyValue,
                timestamp: new Date().toISOString()
            });
            
            // Update human perception based on feedback
            updateHumanPerception(selectedEmotion);
            
            // Update visualization
            updateFrameworkVisualization();
            
            // Show visualization toggle after a few responses
            if (feedbackData.length >= 3 && document.getElementById('vizToggle').style.display !== 'block') {
                document.getElementById('vizToggle').style.display = 'block';
            }
            
            // Hide feedback form
            hideFeedbackForm();
            
            // Switch to adaptive mode after first feedback
            if (currentMode === "rules-based") {
                currentMode = "adaptive";
            }
            
            // For testing - log feedback data
            console.log("Feedback data:", feedbackData);
        }
        
        function updateHumanPerception(emotion) {
            // Map the selected emotion to framework dimensions
            switch(emotion) {
                case "analytical":
                    humanPerception.analytical = 0.1; // Very analytical
                    break;
                case "embodied":
                    humanPerception.analytical = 0.9; // Very embodied
                    break;
                case "temporal":
                    humanPerception.temporal = 0.1; // Very temporal
                    break;
                case "atemporal":
                    humanPerception.temporal = 0.9; // Very atemporal
                    break;
                case "contextual":
                    humanPerception.contextual = 0.1; // Very contextual
                    break;
                case "decontextualized":
                    humanPerception.contextual = 0.9; // Very decontextualized
                    break;
                case "intuitive":
                    humanPerception.intuitive = 0.1; // Very intuitive
                    break;
                case "computational":
                    humanPerception.intuitive = 0.9; // Very computational
                    break;
            }
        }
        
        function toggleVizPanel() {
            const vizPanel = document.getElementById('vizPanel');
            if (vizPanel.style.display === 'block') {
                vizPanel.style.display = 'none';
            } else {
                vizPanel.style.display = 'block';
                updateFrameworkVisualization();
            }
        }
        
        function updateFrameworkVisualization() {
            // Update markers based on current framework values
            document.getElementById('marker-analytical').style.left = `${framework.analytical * 100}%`;
            document.getElementById('marker-temporal').style.left = `${framework.temporal * 100}%`;
            document.getElementById('marker-contextual').style.left = `${framework.contextual * 100}%`;
            document.getElementById('marker-intuitive').style.left = `${framework.intuitive * 100}%`;
            
            // Update summary statistics
            if (feedbackData.length > 0) {
                // Calculate averages
                let totalUncanny = 0;
                let totalAlignment = 0;
                
                feedbackData.forEach(item => {
                    totalUncanny += item.uncannyScore;
                    totalAlignment += item.alignmentScore;
                });
                
                const avgUncanny = totalUncanny / feedbackData.length;
                const avgAlignment = totalAlignment / feedbackData.length;
                
                // Update display
                document.getElementById('responseCount').textContent = `Interactions: ${feedbackData.length}`;
                document.getElementById('uncannyScore').textContent = `Average Uncanny Score: ${avgUncanny.toFixed(1)}/10`;
                document.getElementById('alignmentScore').textContent = `Average Alignment: ${avgAlignment.toFixed(1)}/10`;
            }
        }
        
        function changeNode(nodeName) {
            if (frameworkNodes[nodeName]) {
                currentNode = nodeName;
                
                // Reset the framework to match this node's initial state
                if (nodeName === "rules-based-ai") {
                    framework.analytical = 0.75;
                    framework.temporal = 0.25;
                    framework.contextual = 0.25;
                    framework.intuitive = 0.15;
                } else if (nodeName === "high-fidelity") {
                    framework.analytical = 0.2;
                    framework.temporal = 0.5;
                    framework.contextual = 0.6;
                    framework.intuitive = 0.3;
                } else if (nodeName === "embodied") {
                    framework.analytical = 0.8;
                    framework.temporal = 0.4;
                    framework.contextual = 0.7;
                    framework.intuitive = 0.2;
                } else if (nodeName === "temporal") {
                    framework.analytical = 0.5;
                    framework.temporal = 0.2;
                    framework.contextual = 0.4;
                    framework.intuitive = 0.3;
                } else if (nodeName === "intuitive") {
                    framework.analytical = 0.6;
                    framework.temporal = 0.5;
                    framework.contextual = 0.5;
                    framework.intuitive = 0.1;
                } else if (nodeName === "contextual") {
                    framework.analytical = 0.5;
                    framework.temporal = 0.5;
                    framework.contextual = 0.2;
                    framework.intuitive = 0.5;
                } else if (nodeName === "sharp-rectangle") {
                    framework.analytical = 0.3;
                    framework.temporal = 0.7;
                    framework.contextual = 0.7;
                    framework.intuitive = 0.8;
                } else if (nodeName === "rigid-path") {
                    framework.analytical = 0.2;
                    framework.temporal = 0.8;
                    framework.contextual = 0.8;
                    framework.intuitive = 0.7;
                } else if (nodeName === "repetitive-listing") {
                    framework.analytical = 0.1;
                    framework.temporal = 0.3;
                    framework.contextual = 0.8;
                    framework.intuitive = 0.9;
                }
                
                // Reset to rules-based mode when changing nodes
                currentMode = "rules-based";
                
                // Update the visualization
                updateFrameworkVisualization();
            }
        }
        
        function hideControls() {
            document.getElementById('soundButton').style.display = 'none';
            document.getElementById('nodeSelector').style.display = 'none';
        }
        
        function showControls() {
            document.getElementById('soundButton').style.display = 'flex';
            document.getElementById('nodeSelector').style.display = 'flex';
        }
        
        function startGame() {
            // Remove overlay
            document.getElementById('startOverlay').style.display = 'none';
            
            // Resume AudioContext if suspended
            if (window.audioContext && window.audioContext.state === 'suspended') {
                window.audioContext.resume();
            }
            
            // Try to unlock audio on iOS
            unlockAudio();
            
            // Initialize sounds
            initSounds();
            
            // Show mobile controls
            showControls();
            
            // Start the game
            gameStarted = true;
        }
        
        // Function to handle canvas clicks
        function handleCanvasClick() {
            // Only proceed if game is started and not showing feedback
            if (!gameStarted || showingFeedback) return;
            
            // Create interaction
            createCircles();
            
            // Increment interaction count
            interactionCount++;
            
            // After every 2-3 interactions, show feedback form
            if (interactionCount % 3 === 0) {
                // Wait a moment for the sound to finish
                setTimeout(showFeedbackForm, 1000);
            }
        }
        
        // Function to unlock audio on iOS
        function unlockAudio() {
            // Play silent audio to unlock
            const audioElement = document.createElement('audio');
            audioElement.setAttribute('src', 'data:audio/mp3;base64,SUQzAwAAAAAAIlRJVDIAAAABAAAASVRTUwAAAAEAAABUQ09OAAAABAAAAE11c2ljLw==');
            audioElement.setAttribute('playsinline', 'true');
            audioElement.play();
            
            // Create and play a silent oscillator
            if (window.audioContext) {
                const oscillator = window.audioContext.createOscillator();
                const gainNode = window.audioContext.createGain();
                gainNode.gain.value = 0;
                oscillator.connect(gainNode);
                gainNode.connect(window.audioContext.destination);
                oscillator.start(0);
                oscillator.stop(0.001);
            }
        }
        
        function initSounds() {
            // Force audio context to start
            if (window.audioContext && window.audioContext.state === 'suspended') {
                window.audioContext.resume();
            }
            
            // Add a direct HTML5 audio for fallback
            if (!window.backupAudio) {
                window.backupAudio = new Audio();
                window.backupAudio.src = 'sounds/Bulletsound.mp3';
                window.backupAudio.load();
            }
            
            // Try playing with p5.sound
            if (bulletSound && typeof bulletSound.play === 'function') {
                bulletSound.play();
                bulletSound.stop();
            }
            soundsLoaded = true;
            soundInitialized = true;
        }
        
        function createCircles() {
            // Only proceed if game is started
            if (!gameStarted) return;
            
            // Get the current node configuration
            const node = frameworkNodes[currentNode];
            
            // Make multiple attempts to play sound
            playSound(node.soundFile);
            
            // Create multiple beautiful random circles
            const numCircles = random(5, 12);
            const centerX = soldier.x + soldier.width / 2;
            const centerY = soldier.y + soldier.height / 2;
            
            // Set color scheme based on current mode and node
            let circleColor;
            
            if (currentMode === "rules-based") {
                // In rules-based mode, use the node's defined colors
                if (currentNode === "rules-based-ai" && random() < 0.5) {
                    // For rules-based, alternate between two colors
                    circleColor = color(
                        random(node.altColors.r[0], node.altColors.r[1]),
                        random(node.altColors.g[0], node.altColors.g[1]),
                        random(node.altColors.b[0], node.altColors.b[1])
                    );
                } else {
                    circleColor = color(
                        random(node.colors.r[0], node.colors.r[1]),
                        random(node.colors.g[0], node.colors.g[1]),
                        random(node.colors.b[0], node.colors.b[1])
                    );
                }
            } else {
                // In adaptive mode, blend between node color and framework-adjusted color
                // Calculate framework-influenced color
                const r = map(framework.analytical, 0, 1, 50, 220); 
                const g = map(framework.temporal, 0, 1, 50, 220);
                const b = map(framework.intuitive, 0, 1, 50, 220);
                
                // Blend between node color and framework color
                const blendFactor = 0.3; // How much to adapt (0.0 = node color only, 1.0 = framework color only)
                
                circleColor = color(
                    lerp(random(node.colors.r[0], node.colors.r[1]), r, blendFactor),
                    lerp(random(node.colors.g[0], node.colors.g[1]), g, blendFactor),
                    lerp(random(node.colors.b[0], node.colors.b[1]), b, blendFactor)
                );
            }
            
            for (let i = 0; i < numCircles; i++) {
                const size = random(7, 16);
                
                bullets.push(new Projectile(
                    centerX + random(-15, 15),
                    centerY + random(-15, 15),
                    size, 
                    circleColor,
                    1,
                    node.effectType,
                    node.movementType
                ));
            }
            
            // Set cooldown
            shoot = 1;
            
            // Alternate the character direction for visual interest
            soldier.last_direction = soldier.last_direction === "right" ? "left" : "right";
            
            // If in adaptive mode, gradually shift framework values toward human perception
            if (currentMode === "adaptive") {
                adaptFrameworkToHumanPerception();
            }
        }
        
        function adaptFrameworkToHumanPerception() {
            // Gradually shift framework values toward human perception
            const adaptationRate = 0.1; // How quickly the system adapts
            
            framework.analytical += (humanPerception.analytical - framework.analytical) * adaptationRate;
            framework.temporal += (humanPerception.temporal - framework.temporal) * adaptationRate;
            framework.contextual += (humanPerception.contextual - framework.contextual) * adaptationRate;
            framework.intuitive += (humanPerception.intuitive - framework.intuitive) * adaptationRate;
            
            // Update visualization if visible
            if (document.getElementById('vizPanel').style.display === 'block') {
                updateFrameworkVisualization();
            }
        }
        
        function playSound(soundFile) {
            // Multiple approaches to try to play sound
            try {
                // If a specific sound file is provided, use it
                const soundToPlay = soundFile || 'sounds/Bulletsound.mp3';
                
                // Approach 1: Use p5.sound
                if (soundsLoaded) {
                    if (window.audioContext && window.audioContext.state === 'suspended') {
                        window.audioContext.resume();
                    }
                    
                    if (bulletSound && typeof bulletSound.play === 'function') {
                        bulletSound.play();
                    }
                }
                
                // Approach 2: Use direct HTML5 Audio API as fallback
                if (window.backupAudio) {
                    window.backupAudio.currentTime = 0;
                    window.backupAudio.play();
                }
                
                // Approach 3: Create a new Audio element with the specific sound
                const audio = new Audio(soundToPlay);
                audio.play();
                
            } catch (e) {
                // Silent error handling
            }
        }
        
        // KEYBOARD CONTROL HANDLERS - Simplified to just spacebar
        function keyPressed() {
            if (keyCode === 32) { // Space key
                if (gameStarted && shoot === 0 && !showingFeedback) {
                    handleCanvasClick();
                    if (document.getElementById('soundButton')) {
                        document.getElementById('soundButton').classList.add('active');
                    }
                }
                return false;
            }
        }
        
        function keyReleased() {
            if (keyCode === 32) { // Space key
                if (document.getElementById('soundButton')) {
                    document.getElementById('soundButton').classList.remove('active');
                }
                return false;
            }
        }
        
        function draw() {
            if (!gameStarted) return;
            
            // Clear the canvas each frame
            clear();
            
            // Draw background - use object-fit:cover style approach
            let bgWidth, bgHeight;
            const bgRatio = gridImg.width / gridImg.height;
            const canvasRatio = width / height;
            
            if (bgRatio > canvasRatio) {
                // Background is wider than canvas
                bgHeight = height;
                bgWidth = height * bgRatio;
            } else {
                // Background is taller than canvas
                bgWidth = width;
                bgHeight = width / bgRatio;
            }
            
            // Center the background
            const bgX = (width - bgWidth) / 2;
            const bgY = (height - bgHeight) / 2;
            
            // Draw the background
            image(gridImg, bgX, bgY, bgWidth, bgHeight);
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].draw();
                
                // Remove finished bullets
                if (bullets[i].isFinished()) {
                    bullets.splice(i, 1);
                }
            }
            
            // Handle shoot cooldown
            if (shoot > 0) {
                shoot += 1;
            }
            if (shoot > 3) {
                shoot = 0;
            }
            
            // Draw character
            soldier.draw();
        }
        
        function windowResized() {
            // Resize canvas maintaining aspect ratio
            let canvasWidth, canvasHeight;
            
            if (windowWidth / windowHeight > W_WIDTH / W_HEIGHT) {
                // Window is wider than the target aspect ratio
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * (W_WIDTH / W_HEIGHT);
            } else {
                // Window is taller than the target aspect ratio
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth * (W_HEIGHT / W_WIDTH);
            }
            
            resizeCanvas(canvasWidth, canvasHeight);
            
            // Reposition sound button
            if (gameStarted) {
                // Adjust sound button
                const soundBtn = document.getElementById('soundButton');
                soundBtn.style.bottom = '20px';
            }
        }
        
        // Additional handler to help with iOS audio
        function touchStarted() {
            unlockAudio();
            return false;
        }
        
        // Mouse click handler (for sound activation)
        function mousePressed() {
            unlockAudio();
            return false;
        }
    </script>
</body>
</html>
